//go:build !test
// +build !test

// @title Climate Bridge API
// @version 1.0
// @description The Climate Bridge API server for the Climate Bridge App.
// @license.name MIT
// @license.url http://opensource.org/licenses/MIT
// @BasePath /api
package main

import (
	"context"
	"net/http"
	"os"
	"strings"

	_ "go-typescript-react-boilerplate/src/server/docs-autogenerated"
	endpoints_Common "go-typescript-react-boilerplate/src/server/endpoints/common"

	"github.com/gin-contrib/gzip"
	"github.com/gin-gonic/gin"
	swaggerFiles "github.com/swaggo/files"
	ginSwagger "github.com/swaggo/gin-swagger"
)

func main() {
	ctx := context.Background()

	host := "localhost"
	indexLocation := "../../dist"

	if os.Getenv("DOCKER_ENV") == "true" {
		host = "0.0.0.0"
		indexLocation = "./"
	}

	url := host + ":8080"

	router := gin.New()

	router.Use(gzip.Gzip(gzip.DefaultCompression, gzip.WithExcludedExtensions([]string{".png", ".jpg", ".zip", ".gz", ".rar", ".7z"}), gzip.WithExcludedPaths([]string{"/api"})))
	router.Use(func(c *gin.Context) {
		if strings.Contains(c.Request.URL.Path, "/static") {
			// The Cache-Control header controls how the file is cached. The "public" option
			// means the file can be cached by any cache, including the browser cache and
			// shared caches like a CDN. The "max-age" option controls how long the file is
			// cached for, in seconds. 31536000 seconds is one year.
			c.Header("Cache-Control", "public, max-age=31536000")
		}
		// Call the Next function to continue with the HTTP handler.
		// This is necessary in middleware functions to prevent blocking the rest of the handler chain.
		c.Next()
	})

	router.GET("/", func(c *gin.Context) {
		c.File(indexLocation + "/index.html")
	})

	apiGroup := router.Group("/api")

	// Handle the Swagger UI route.
	apiGroup.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))

	// --- Edit below to add new endpoint groups ---
	commonGroup := apiGroup.Group("/common")
	endpoints_Common.Common(commonGroup, ctx)
	// --- Finish editing here ---

	router.NoRoute(func(c *gin.Context) {
		requestPath := c.Request.URL.Path
		if strings.HasPrefix(requestPath, "/api") {
			c.JSON(http.StatusNotFound, gin.H{"message": "Not found"})
		} else {
			if requestPath[0] == '/' {
				requestPath = requestPath[1:]
			}
			fullPath := indexLocation + "/" + requestPath
			if _, err := os.Stat(fullPath); os.IsNotExist(err) {
				c.File(indexLocation + "/index.html")
			} else {
				c.File(fullPath)
			}
		}
	})

	router.Run(url)
}
