const fs = require('fs');
const path = require('path');
const gulp = require('gulp');
const shell = require('gulp-shell');
const nodemon = require('gulp-nodemon');
const { exec } = require('child_process');

const runCommand = command => {
  return cb => {
    exec(command, function (err, stdout, stderr) {
      console.log(stdout);
      console.log(stderr);
      cb(err);
    });
  };
};

gulp.task('go-mod-tidy', runCommand('go mod tidy'));
gulp.task('gulp-install-tools', runCommand('gulp install-tools'));
gulp.task('husky-install', runCommand('npx husky install'));
gulp.task('husky-add', function (cb) {
  const huskyFilePath = path.join('.husky', 'pre-commit');
  const command = 'npm run precommit';

  fs.readFile(huskyFilePath, 'utf8', function (err, data) {
    if (err) {
      return cb(err);
    }

    if (!data.includes(command)) {
      exec(
        `npx husky add ${huskyFilePath} "${command}"`,
        function (err, stdout, stderr) {
          console.log(stdout);
          console.log(stderr);
          cb(err);
        }
      );
    } else {
      cb();
    }
  });
});
gulp.task('format', runCommand('npm run format'));
gulp.task(
  'setup',
  gulp.series(
    'go-mod-tidy',
    'gulp-install-tools',
    'husky-install',
    'husky-add',
    'format'
  )
);

gulp.task('install-tools', function (done) {
  // Read tools.go file
  fs.readFile('src/server/tools.go', 'utf8', function (err, data) {
    if (err) {
      return console.log(err);
    }

    // Find lines with import paths
    const importLines = data.match(/_ "(.*)"/g);

    if (!importLines) {
      console.log('No tools to install.');
      done();
      return;
    }

    // Extract import paths and install tools
    for (let line of importLines) {
      const importPath = line.match(/_ "(.*)"/)[1];
      const cmd = `go install ${importPath}@latest`;
      shell.task(cmd)();
    }

    done();
  });
});

gulp.task('devBackend', function () {
  let stream = nodemon({
    ext: 'go',
    watch: ['src/server/**/*', '!src/server/docs/**/*'],
    exec: 'swag init -d ./src/server,./src/server/endpoints,./src/server/types -o ./src/server/docs && openapi --input ./src/server/docs/swagger.json --output ./src/client/src/api-autogenerated && prettier --write ./src/client/src/api-autogenerated && prettier --write ./src/server/docs && go run src/server/main.go',
    stdout: true,
    stderr: true,
  });

  stream
    .on('restart', function () {
      console.log('Server Restarted!');
    })
    .on('crash', function () {
      console.error('Application has crashed!\n');
      stream.emit('restart', 10); // restart the server in 10 seconds
    });
});

gulp.task('build:apiSchema', function () {
  return shell.task([
    'swag init -d ./src/server,./src/server/endpoints,./src/server/types -o ./src/server/docs',
    'openapi --input ./src/server/docs/swagger.json --output ./src/client/src/api-autogenerated',
    'prettier --write ./src/client/src/api-autogenerated',
    'prettier --write ./src/server/docs',
  ])();
});

gulp.task(
  'server:unit:test',
  shell.task([
    'go test -cover -coverprofile=coverage.out ./src/server/endpoints',
    'go tool cover -func=coverage.out > coverage-text.txt',
    'rimraf coverage.out',
  ])
);

gulp.task('server:unit:coverage', function (done) {
  const lines = fs
    .readFileSync('coverage-text.txt', 'utf-8')
    .split('\n')
    .filter(Boolean);

  const failedFiles = [];

  let minPercentage = 80.0;

  console.log('minPercentage:', minPercentage);

  console.log('Checking coverage...');

  for (let line of lines) {
    const parts = line.split(/\s+/);
    parts[2] = parts[2].replace(/%/g, '');
    const coverage = parseFloat(parts[2]);
    if (isNaN(coverage) === false && coverage < minPercentage) {
      failedFiles.push(parts[1] + ' | ' + parts[2] + '%');
    }
  }
  if (failedFiles.length > 0) {
    console.error('Functions with coverage less than ' + minPercentage + '%:');
    console.error(failedFiles.join('\n'));
    done(new Error('Coverage check failed.'));
  } else {
    console.log('Coverage is good!');
    try {
      exec('rimraf coverage-text.txt');
    } catch (e) {
      console.error(e);
    }
    done();
  }
});

function getTimestamp() {
  const now = new Date();
  return now.toISOString().replace(/:/g, '-'); // replace ':' with '-' because ':' is not allowed in docker tag
}

gulp.task('container', function () {
  const version = process.env.GITHUB_SHA
    ? process.env.GITHUB_SHA.substring(0, 7)
    : getTimestamp();

  let repoName = process.env.GITHUB_REPOSITORY;
  const imageName = repoName
    ? `ghcr.io/${repoName}`.toLowerCase()
    : 'go-typescript-react-boilerplate';

  return shell.task([`docker build --no-cache -t ${imageName}:${version} .`])();
});

gulp.task('test:go:formatting', function (done) {
  exec('gofmt -l .', function (err, stdout) {
    console.log('incorrect format: ' + stdout);
    if (err || stdout) {
      done(new Error('gofmt found unformatted files or reported an error.'));
    } else {
      done();
    }
  });
});

gulp.task('checkAPISchema', function (done) {
  var dirPath = './src/client/src/api-autogenerated';

  fs.access(dirPath, fs.constants.F_OK, err => {
    if (err) {
      console.log('Directory does not exist, running build:apiSchema...');
      shell.task('gulp build:apiSchema')();
    } else {
      console.log('Directory exists, skipping build:apiSchema');
    }
    done();
  });
});
